<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: Riley Udagawa </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-rileyy/hw3/index.html">https://cal-cs184-student.github.io/hw-webpages-rileyy/hw3/index.html</a> <br>
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw3-rileyyy">https://github.com/cal-cs184-student/sp25-hw3-rileyyy</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>
		Generating camera rays involves taking image coordinates and transforming them into a world space ray. My process took the 1 by 1 square image space and translated it into the virtual camera sensor, being able to scale and transform the inputs.  Then I configured the new ray with parameters based on the transformed input as well as other Camera variables.  In order to generate pixel samples, I did a Monte Carlo estimate of the vector value of the pixel in order to estimate the integral of radiance over it. For the given pixel, I would generate a certai amounts of samples and average them to get the final pixel value.  <br><br>
		
		For ray-triangle intersection, I implemented the Moller-Trumbore algorithm which is an optimized way to find the time t and two of the barycentric coordinates of the intersection. Generally, it involves taking the equation of a ray and the equation of a plane and solving for an intersection using vector operations like dot product, cross product, and others.  The calculations allow us to get the time at which the ray hits the triangle, as well as the two (the third is 1-b1-b2) barycentric coordinates of the intersection. For the ray-sphere intersection, I do a similar process which is solving for the intersection of the given ray and sphere using their equations.  This results in a quadratic for which I use the quadratic equation to solve if it has 0, 1, or 2 intersections. 0 means it does not intersect.  1 means it intersects one time tangentially, and 2 means it goes through the sphere so I take the closest one.    <br><br>

		<p>Normal Shading</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBempty.png" width="400px"/>
				  <figcaption>CBempty</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="banana.png" width="400px"/>
				  <figcaption>banana</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="CBspheres.png" width="400px"/>
				  <figcaption>CBspheres</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny.png" width="400px"/>
				  <figcaption>CBbunny</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		In order to construct my bounding volume hierarchy, I employed a recursive algorithm to create and traverse this binary tree. Given the start/end of a Primitive vector and the max leaf size as well as the BVHAccel class, I first create a bounding box over all of the primitives inputted in.  Then, I create a new node that will be mutated and returned later, starting the recursion process.  If the max leaf size is greater than the amount of primitives left in the iterator, then the node is a leaf node.  If not, the I proceed onto the splitting part.   <br><br>
		The heuristic I chose in order to find the splitting point is the average of the centroids along the largest axis.  Following this, I put primitives into a left vector and a right one depending on their position compared to the splitting point.  Then, I pass the new set of primitives into a recursive call to construct the other leaves.  <br><br>

		<p>Normal Shading with BVH Acceleration</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="Blob.png" width="400px"/>
				  <figcaption>Blob</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBlucy.png" width="400px"/>
				  <figcaption>CBlucy</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="dragon.png" width="400px"/>
				  <figcaption>dragon</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="maxplanck.png" width="400px"/>
				  <figcaption>maxplanck</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		Compared to the rendering times in part 1, the Bounding Volume Hierarchy acceleration significantly optimizes rendering scenes with moderately complex geometries. For instance, the cow goes from 21.2960s to a 0.0820s rendering time. Similarly, the beast, a more complex geometry, goes from 276.3363s to 0.0701s. Lastly, even the teapot goes from 8.8300s to 0.0682s. The PathTracer information printed for me during rendering shows how for the beast's BVH acceleration, the average speed was almost 6 million rays per second whereas its original speed was 0.0016 million rays per second, showing such a huge difference. All of the BVH accelerations dropped the times to less than a second whereas you can see that without it, the more complex geometries can get into super long rendering times.  <br><br>

		<p>Scenes with Compared Rendering Times</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="cow.png" width="400px"/>
				  <figcaption>cow</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="beast.png" width="400px"/>
				  <figcaption>beast</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>teapot</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Part 3: Direct Illumination</h2>
		To implement direct lighting with uniform hemisphere sampling, I am estimating the light that reaches the camera from some intersection point that is reflecting light.  The process involves sampling a certain amount of rays that would reach the camera from the intersection point, which in this case is a uniform sample from the hemisphere. Then I check if these samples then intersect an light source (i.e. a light would shine on a reflection point which would secondarily shine onto the camera). Then, I use these values to form the Monte Carlo estimator for the reflection equation, estimating the light in the scene.  <br><br>

		The direct lighting by importance sampling is a similar process and structure to the previous method. The main difference is that I am sampling all of the lights directly, the main purpose being that it allows for lights originating from a single point. The main idea of this method is that I am sampling light rays and seeing if they hit the hit point, i.e. seeing if light is being shone on them.  In this method, I sample a certain amount from each light source, and only adding the light reflection term if the light ray is not intersecting another object on the way to the point.  Then, I can calculate the Monte Carlo estimator for the reflection equation like before. <br><br>

		Comparing the uniform hemisphere sampling and lighting sampling, sampling the lights themselves clearly make a huge difference in the results as well as allowing for point lights whereas uniform hemisphere sampling basically makes it impossible to find the point lights.  When comparing these two sampling methods with the exact same parameters, the importance sampling has strikingly better results visually.  There is much less static in the importance sampling and a much clearer rendering overall.  It also took a shorter amount of time to render, which is surprising because of how much of a visual difference there is. Even the testing images that I used for the importance sampling one, which was using 1 camera ray per pixel, 1 sample per area light, and 1 max ray depth, was not much worse than some of the uniform hemisphere results.  <br><br>

		<p>Direct Lighting Scenes with Uniform Hemisphere Sampling vs Importance Sampling</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_H_16_8.png" width="400px"/>
				  <figcaption>Uniform Hemisphere Sampling CBbunny_H_16_8</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_H_64_32.png" width="400px"/>
				  <figcaption>Uniform Hemisphere Sampling CBbunny_H_64_32</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny_64_32.png" width="400px"/>
				  <figcaption>Importance Sampling bunny_64_32</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="dragon_64_32.png" width="400px"/>
				  <figcaption>Importance Sampling dragon_64_32</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		I focused on the dragon scene and rendered with 1 sample per pixel and 1/4/16/64 light rays using direct lighting importance sampling as shown below. With only one light ray, the image is very noisy with only the main shapes and most contrasting shadows being super discernable.  As I add more light rays, the image becomes much smoother and the noise goes down considerably.  The soft shadows are much clearer which make the areas with a lighter shadow more defined compared to the previous iterations.  An example of this can be seen if you compare the shadow behind (the the top left of) the dragon which is not noticeable in the 1 light ray one but very clear in the 64 ray image.  <br><br>

		<p>Direct Lighting Importance Sampling with Varying Amounts of Light Rays</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="dragon_1_1.png" width="400px"/>
				  <figcaption>Dragon with 1 Light Ray and 1 Sample per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="dragon_4_1.png" width="400px"/>
				  <figcaption>Dragon with 4 Light Rays and 1 Sample per Pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="dragon_16_1.png" width="400px"/>
				  <figcaption>Dragon with 16 Light Rays and 1 Sample per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="dragon_64_1.png" width="400px"/>
				  <figcaption>Dragon with 64 Light Rays and 1 Sample per Pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Part 4: Global Illumination</h2>
		_+__+_+__Walk through your implementation of the indirect lighting function <br><br>

		<p>Global Illumination Images 1024 Samples per Pixel</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_1024.png" width="400px"/>
				  <figcaption>Global Illumination Spheres with 1024 Samples per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_1024.png" width="400px"/>
				  <figcaption>Global Illumination Bunny with 1024 Samples per Pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		The following spheres scene compares direct illumination versus indirect illumination. The direct scene has more vivid colors and lights whereas the indirect scene is more dull and muted.  This is because the indirect scene is only getting secondhand light reflection, not from the source directly. <br><br>

		<p>Direct Versus Indirect Illumination Images 1024 Samples per Pixel</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_direct.png" width="400px"/>
				  <figcaption>Direct Illumination Spheres with 1024 Samples per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_indirect.png" width="400px"/>
				  <figcaption>Indirect Illumination Spheres with 1024 Samples per Pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		Below shows CBbunny rendered with (0,1,2,3,4,5) bounces of light (max_ray_depth), first without accumulating bounces and then with accumulating bounces. When isolating the 2nd and 3rd bounce of light in the non-accumulating bunny images, the color of the walls start to bleed onto the bunny as the light reflected the color from the walls onto the bunny.  This by itself gives an edge over rasterization because it would be very difficult for rasterization to receive information from across the scene, showing how light rays seem to be a very easy way of showing realism in light and color reflection.  <br><br>

		<p>CBbunny WITHOUT Accumulating Bounces with Max Ray Depth (0,1,2,3,4,5)</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_m0.png" width="250px"/>
				  <figcaption>Bunny with 0 Light Bounces and No Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m1.png" width="250px"/>
				  <figcaption>Bunny with 1 Light Bounce and No Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m2.png" width="250px"/>
				  <figcaption>Bunny with 2 Light Bounces and No Accumulation</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_m3.png" width="250px"/>
				  <figcaption>Bunny with 3 Light Bounces and No Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m4.png" width="250px"/>
				  <figcaption>Bunny with 4 Light Bounces and No Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m5.png" width="250px"/>
				  <figcaption>Bunny with 5 Light Bounces and No Accumulation</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		Comparing the accumulating vs the unaccumulating bounces, the unaccumulating images become dull quickly as the light is fading seen through comparing 1 bounce to 2 bounces.  On the other hand, the accumulating images keep their color and light very well, the thing fading the most over bounces being the color contrast.  By the end, the image has less contrasting colors than before but the walls are more colored than the unaccumulated. <br><br>

		<p>CBbunny WITH Accumulating Bounces with Max Ray Depth (0,1,2,3,4,5)</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_m0_acc.png" width="250px"/>
				  <figcaption>Bunny with 0 Light Bounces and Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m1_acc.png" width="250px"/>
				  <figcaption>Bunny with 1 Light Bounce and Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m2_acc.png" width="250px"/>
				  <figcaption>Bunny with 2 Light Bounces and Accumulation</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_m3_acc.png" width="250px"/>
				  <figcaption>Bunny with 3 Light Bounces and Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m4_acc.png" width="250px"/>
				  <figcaption>Bunny with 4 Light Bounces and Accumulation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m5_acc.png" width="250px"/>
				  <figcaption>Bunny with 5 Light Bounces and Accumulation</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		Below shows CBbunny Russian Roulette rendered with (0,1,2,3,4,100) bounces of light (max_ray_depth).  <br><br>

		<p>CBbunny Russian Roulette with Max Ray Depth (0,1,2,3,4,100)</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_m0_rr.png" width="250px"/>
				  <figcaption>Bunny with 0 Light Bounces and Russian Roulette</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m1_rr.png" width="250px"/>
				  <figcaption>Bunny with 1 Light Bounce and Russian Roulette</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m2_rr.png" width="250px"/>
				  <figcaption>Bunny with 2 Light Bounces and Russian Roulette</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_m3_rr.png" width="250px"/>
				  <figcaption>Bunny with 3 Light Bounces and Russian Roulette</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m4_rr.png" width="250px"/>
				  <figcaption>Bunny with 4 Light Bounces and Russian Roulette</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_m100_rr.png" width="250px"/>
				  <figcaption>Bunny with 100 Light Bounces and Russian Roulette</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		Below shows Spheres rendered with (1,2,4,8,16,64,1024) sample per pixel rates.  <br><br>

		<p>Spheres with (1,2,4,8,16,64,1024) Sample per Pixel Rates</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_s1.png" width="250px"/>
				  <figcaption>Sphere with 1 Sample per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_s2.png" width="250px"/>
				  <figcaption>Sphere with 2 Samples per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_s4.png" width="250px"/>
				  <figcaption>Sphere with 4 Samples per Pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_s8.png" width="250px"/>
				  <figcaption>Sphere with 8 Samples per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_s16.png" width="250px"/>
				  <figcaption>Sphere with 16 Samples per Pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_s64.png" width="250px"/>
				  <figcaption>Sphere with 64 Samples per Pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_s1024.png" width="250px"/>
				  <figcaption>Sphere with 1024 Samples per Pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>